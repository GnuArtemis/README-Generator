// Require all dependencies needed: inquirer, fs, path
const inquirer = require("inquirer");
const fs = require("fs");
const path = require("path");


//Questions and licenses are big question object blocks/text blocks that live outside this function due to size. Questions include the main series of questions, asked every session, and licenses includes the text of the GNU lv3 license and the MIT license.
const { questions } = require('./questions');
const { licenses } = require('./licenses');
//answers takes responses from the standard set of questions and saves it to the global scope, so it be accessed at any time.
let answers;

//Write a README in a markdon file as a template function that will generate my readme template, use inquirer to prompt users with questions, use answers that come back from inquirer - pass those into generate README function, and then write file using template generated from readme function
inquirer
    .prompt(questions)
    .then(saveResult, errHandler)
    .then(createText, errHandler)
    .then(createImages, errHandler)
    .then(createTechnologies, errHandler)
    .then(continueText, errHandler)
    .then(createTest, errHandler)
    .then(createOtherAuthors, errHandler)
    .then(finishText, errHandler)
    .then(createLicense, errHandler)
    .then(writeReadme, errHandler);

//Error handler, saved for a cleaner promise chain.
function errHandler(err) {
    if (err) console.log(err);
}

//Saves the results generated by the questions for global access.
function saveResult(result) {
    answers = result;
    return result;
}

//Begins the process of creating a README Template. These sections appear every case, though certain elements of the table of contents may or may not appear depending on answer responses
function createText(result) {
    let text =
`# ${answers.projectTitle}
## Description
${answers.description}

## Table of Contents
1. [Description](#-Description)`;


    if (answers.visuals > 0) text += `\r\n1. [Visuals](#Visuals)`;

    text +=
`\r\n1. [Installation](#Installation)
1. [Usage](#Usage)
1. [Contributing](#Contributing)\r\n`;


    if (answers.tests) text += `1. [Tests](#Tests)\r\n`;
    if (answers.otherAuthors > 0) text += `1. [Authors](#Authors)\r\n`;

    text +=
`1. [Questions](#Questions)
1. [License](#License)\r\n\r\n`
    return text;
}

//Asynchronous function handles the case in which user elected to add images. Adds Image description and proper markdown image formatting for as many images as the user indicated they wished to add.
async function createImages(text) {
    let newText = "";
    if (answers.images > 0) {
        newText += `## Visuals \r\n\r\n`;
        for (i = 0; i < answers.images; i++) {
            await inquirer
                .prompt([
                    {
                        type: "input",
                        message: "Please enter a short description of the image.",
                        name: "imageDesc"
                    },
                    {
                        type: "input",
                        message: "What is the relative or absolute link to the image you want to add?",
                        name: "link"
                    },
                ]).then(function (res) {
                    let imageText = `![image](${res.link})`;
                    imageText += "\r\n\r\n"
                    imageText += res.imageDesc;
                    imageText += "\r\n\r\n"

                    newText += imageText;
                })

        }
    }
    return (text + newText);
}

//Asynchronous function handles the case in which user elected to add technologies. Adds technology name and link/attribution for as many technologies as the user indicated they wished to add.
async function createTechnologies(text) {
    let newText = "";
    if (answers.technologies > 0) {
        newText += `## Technologies \r\n\r\n`;
        for (i = 0; i < answers.technologies; i++) {
            await inquirer
                .prompt([
                    {
                        type: "input",
                        message: "What is the name of the technology used?",
                        name: "techname"
                    }, {
                        type: "input",
                        message: "What is the relative or absolute link to attribute the technology?",
                        name: "link"
                    }
                ]).then(function (res) {
                    let tech = `[${res.techname}](${res.link})`;
                    tech += "\r\n\r\n";

                    newText += tech;
                })

        }
    }
    return (text + newText);
}

//Continues the process of adding text to the README template. These sections appear every case.
function continueText(text) {
    const newText =
`## Installation
${answers.installation}

## Usage
${answers.usage}
    
## Contributing
${answers.contributing}`;


    return text + newText + "\r\n\r\n";
}

//Asynchronous function handles the case in which user elected to add test instructions. Adds a paragraph of test instructions, per user input.
async function createTest(text) {
    let newText = "";
    if (answers.tests) {
        newText += `## Tests\r\n\r\n`
        await inquirer
            .prompt([
                {
                    type: "input",
                    message: "Please enter your test instructions in one paragraph.",
                    name: "testContents"
                }
            ]).then(function (res) {
                newText += res.testContents + "\r\n\r\n";
            });


    }
    return (text + newText);
}

//Asynchronous function handles the case in which user wishes to acknowledge additional contributors/authors. Adds author name/github username and link/attribution for as many authors as the user indicated they wished to add.
async function createOtherAuthors(text) {
    let newText = "";
    if (answers.otherAuthors > 0) {
        newText += "## Authors \r\n\r\n";
        for (i = 0; i < answers.otherAuthors; i++) {
            await inquirer
                .prompt([
                    {
                        type: "input",
                        message: "What was a contributor's name?",
                        name: "authorName"
                    },
                    {
                        type: "input",
                        message: "What was their github username?",
                        name: "authorGithub"
                    }
                ]).then(function (res) {
                    let author = `[${res.authorName}](https://github.com/${res.authorGithub})`;
                    author += "\r\n\r\n"

                    newText += author;
                })

        }

    }
    return (text + newText);
}

//Continues the process of creating a README Template. These sections appear every case.
function finishText(text) {
    newText =
`## Questions
Please direct questions to:
Github account ${answers.questionsGithub}
${answers.questionsEmail} \r\n\r\n`;

    return text + newText;
}

//Asynchronous function handles adding the license and license badge. The user can either choose to add the 2 most common licenses, MIT or GNU v3, or, if they are choosing another license, they can pull directly from a github LICENSE file if one exists, or add the text directly.
async function createLicense(text) {
    let newText = `## License \r\n\r\n`
    newText += `![GitHub](https://img.shields.io/github/license/${answers.questionsGithub}/${answers.projectTitle}) \r\n\r\n`;

    if (answers.license === "MIT") {
        newText += licenses.MIT
    } else if (answers.license === "GNU GPLv3") {
        newText += licenses.GNU
    } else {
        await inquirer
            .prompt([
                {
                    type: "confirm",
                    message: "Do you already have a license file from Github?",
                    name: "preexistingLicense"
                },
                {
                    type: "input",
                    when: (res) => !res.preexistingLicense,
                    message: "Please enter the title of the license you wish to use",
                    name: "licenseTitle"
                },
                {
                    type: "input",
                    when: (res) => !res.preexistingLicense,
                    message: "Please enter the text of the license you wish to use",
                    name: "licenseText"
                }
            ]).then(function (res) {
                if (res.preexistingLicense) {
                    const data = fs.readFileSync('LICENSE', "utf8");
                    newText += data;
                } else {
                    let uniqueLicense = res.licenseTitle;
                    uniqueLicense += "\r\n\r\n"
                    uniqueLicense += res.licenseText;
                    uniqueLicense += "\r\n\r\n"

                    newText += uniqueLicense;
                }
            })
    }
    return text + newText;
}

//Takes the completed README text as a parameter and writes it to README.md in the "output" folder.
function writeReadme(text) {
    const OUTPUT_DIR = path.resolve(__dirname, "output");
    const outputPath = path.join(OUTPUT_DIR, "README.md");
    fs.writeFile(outputPath, text, errHandler);
}
